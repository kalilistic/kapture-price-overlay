{"version":3,"sources":["webpack:///./node_modules/flatted/esm/index.js","webpack:///./node_modules/javascript-stringify/dist/index.js","webpack:///./node_modules/ieee754/index.js","webpack:///./node_modules/javascript-stringify/dist/function.js","webpack:///./node_modules/javascript-stringify/dist/object.js","webpack:///./node_modules/javascript-stringify/dist/array.js","webpack:///./node_modules/isarray/index.js","webpack:///./node_modules/javascript-stringify/dist/stringify.js","webpack:///./node_modules/javascript-stringify/dist/quote.js"],"names":["Flatted","Primitive","primitive","parse","text","reviver","input","JSON","Primitives","map","primitives","value","$","noop","tmp","revive","Set","call","stringify","replacer","space","firstRun","known","Map","output","k","v","indexOf","i","set","replace","key","after","this","get","length","join","parsed","Object","keys","reduce","has","add","index","push","String","defineProperty","exports","stringify_1","quote_1","ROOT_SENTINEL","Symbol","indent","options","repeat","path","stack","tracking","unpack","valueCount","maxDepth","references","skipUndefinedProperties","maxValues","valueToString","replacerToString","onNext","undefined","result","builder","pop","slice","delete","size","sp","eol","wrapper","entries","keyPath","stringifyPath","valuePath","next","toString","read","buffer","offset","isLE","mLen","nBytes","e","m","eLen","eMax","eBias","nBits","d","s","NaN","Infinity","Math","pow","write","c","rt","abs","isNaN","floor","log","LN2","METHOD_NAMES_ARE_QUOTED","charAt","FUNCTION_PREFIXES","Function","GeneratorFunction","AsyncFunction","AsyncGeneratorFunction","METHOD_PREFIXES","TOKENS_PRECEDING_REGEXPS","split","dedentFunction","fnString","found","line","exec","str","USED_METHOD_KEY","WeakSet","functionToString","fn","name","FunctionParser","pos","hadKeyword","prototype","fnType","constructor","keyQuote","quoteKey","keyPrefix","isMethodCandidate","tryParse","tryStrippingName","prevPos","consumeSyntax","tryParsePrefixTokens","substr","getPrefix","start","prefix","isValidVariableName","posPrev","token","wordLikeToken","consumeMatch","match","consumeWhitespace","consumeSyntaxUntil","consumeTemplate","consumeRegExp","startToken","endToken","isRegExpAllowed","re","function_1","array_1","objectToString","Buffer","isBuffer","OBJECT_TYPES","rawObjectToString","obj","values","globalToString","arrayToString","error","message","date","getTime","num","bool","Array","from","array","module","isArray","arr","object_1","PRIMITIVE_TYPES","string","quoteString","number","is","boolean","symbol","keyFor","description","bigint","object","function","ESCAPABLE","META_CHARS","escapeChar","char","charCodeAt","RESERVED_WORDS","IS_VALID_IDENTIFIER","test"],"mappings":"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","file":"js/chunk-vendors~203e0718.7538c8d5.js","sourcesContent":["var Flatted = (function (Primitive, primitive) {\n\n  /*!\n   * ISC License\n   *\n   * Copyright (c) 2018, Andrea Giammarchi, @WebReflection\n   *\n   * Permission to use, copy, modify, and/or distribute this software for any\n   * purpose with or without fee is hereby granted, provided that the above\n   * copyright notice and this permission notice appear in all copies.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n   * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n   * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n   * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n   * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n   * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n   * PERFORMANCE OF THIS SOFTWARE.\n   */\n\n  var Flatted = {\n\n    parse: function parse(text, reviver) {\n      var input = JSON.parse(text, Primitives).map(primitives);\n      var value = input[0];\n      var $ = reviver || noop;\n      var tmp = typeof value === 'object' && value ?\n                  revive(input, new Set, value, $) :\n                  value;\n      return $.call({'': tmp}, '', tmp);\n    },\n\n    stringify: function stringify(value, replacer, space) {\n      for (var\n        firstRun,\n        known = new Map,\n        input = [],\n        output = [],\n        $ = replacer && typeof replacer === typeof input ?\n              function (k, v) {\n                if (k === '' || -1 < replacer.indexOf(k)) return v;\n              } :\n              (replacer || noop),\n        i = +set(known, input, $.call({'': value}, '', value)),\n        replace = function (key, value) {\n          if (firstRun) {\n            firstRun = !firstRun;\n            return value;\n          }\n          var after = $.call(this, key, value);\n          switch (typeof after) {\n            case 'object':\n              if (after === null) return after;\n            case primitive:\n              return known.get(after) || set(known, input, after);\n          }\n          return after;\n        };\n        i < input.length; i++\n      ) {\n        firstRun = true;\n        output[i] = JSON.stringify(input[i], replace, space);\n      }\n      return '[' + output.join(',') + ']';\n    }\n\n  };\n\n  return Flatted;\n\n  function noop(key, value) {\n    return value;\n  }\n\n  function revive(input, parsed, output, $) {\n    return Object.keys(output).reduce(\n      function (output, key) {\n        var value = output[key];\n        if (value instanceof Primitive) {\n          var tmp = input[value];\n          if (typeof tmp === 'object' && !parsed.has(tmp)) {\n            parsed.add(tmp);\n            output[key] = $.call(output, key, revive(input, parsed, tmp, $));\n          } else {\n            output[key] = $.call(output, key, tmp);\n          }\n        } else\n          output[key] = $.call(output, key, value);\n        return output;\n      },\n      output\n    );\n  }\n\n  function set(known, input, value) {\n    var index = Primitive(input.push(value) - 1);\n    known.set(value, index);\n    return index;\n  }\n\n  // the two kinds of primitives\n  //  1. the real one\n  //  2. the wrapped one\n\n  function primitives(value) {\n    return value instanceof Primitive ? Primitive(value) : value;\n  }\n\n  function Primitives(key, value) {\n    return typeof value === primitive ? new Primitive(value) : value;\n  }\n\n}(String, 'string'));\nexport default Flatted;\nexport var parse = Flatted.parse;\nexport var stringify = Flatted.stringify;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst stringify_1 = require(\"./stringify\");\nconst quote_1 = require(\"./quote\");\n/**\n * Root path node.\n */\nconst ROOT_SENTINEL = Symbol(\"root\");\n/**\n * Stringify any JavaScript value.\n */\nfunction stringify(value, replacer, indent, options = {}) {\n    const space = typeof indent === \"string\" ? indent : \" \".repeat(indent || 0);\n    const path = [];\n    const stack = new Set();\n    const tracking = new Map();\n    const unpack = new Map();\n    let valueCount = 0;\n    const { maxDepth = 100, references = false, skipUndefinedProperties = false, maxValues = 100000 } = options;\n    // Wrap replacer function to support falling back on supported stringify.\n    const valueToString = replacerToString(replacer);\n    // Every time you call `next(value)` execute this function.\n    const onNext = (value, key) => {\n        if (++valueCount > maxValues)\n            return;\n        if (skipUndefinedProperties && value === undefined)\n            return;\n        if (path.length > maxDepth)\n            return;\n        // An undefined key is treated as an out-of-band \"value\".\n        if (key === undefined)\n            return valueToString(value, space, onNext, key);\n        path.push(key);\n        const result = builder(value, key === ROOT_SENTINEL ? undefined : key);\n        path.pop();\n        return result;\n    };\n    const builder = references\n        ? (value, key) => {\n            if (value !== null &&\n                (typeof value === \"object\" ||\n                    typeof value === \"function\" ||\n                    typeof value === \"symbol\")) {\n                // Track nodes to restore later.\n                if (tracking.has(value)) {\n                    unpack.set(path.slice(1), tracking.get(value));\n                    return; // Avoid serializing referenced nodes on an expression.\n                }\n                // Track encountered nodes.\n                tracking.set(value, path.slice(1));\n            }\n            return valueToString(value, space, onNext, key);\n        }\n        : (value, key) => {\n            // Stop on recursion.\n            if (stack.has(value))\n                return;\n            stack.add(value);\n            const result = valueToString(value, space, onNext, key);\n            stack.delete(value);\n            return result;\n        };\n    const result = onNext(value, ROOT_SENTINEL);\n    // Attempt to restore circular references.\n    if (unpack.size) {\n        const sp = space ? \" \" : \"\";\n        const eol = space ? \"\\n\" : \"\";\n        let wrapper = `var x${sp}=${sp}${result};${eol}`;\n        for (const [key, value] of unpack.entries()) {\n            const keyPath = quote_1.stringifyPath(key, onNext);\n            const valuePath = quote_1.stringifyPath(value, onNext);\n            wrapper += `x${keyPath}${sp}=${sp}x${valuePath};${eol}`;\n        }\n        return `(function${sp}()${sp}{${eol}${wrapper}return x;${eol}}())`;\n    }\n    return result;\n}\nexports.stringify = stringify;\n/**\n * Create `toString()` function from replacer.\n */\nfunction replacerToString(replacer) {\n    if (!replacer)\n        return stringify_1.toString;\n    return (value, space, next, key) => {\n        return replacer(value, space, (value) => stringify_1.toString(value, space, next, key), key);\n    };\n}\n//# sourceMappingURL=index.js.map","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst quote_1 = require(\"./quote\");\n/**\n * Used in function stringification.\n */\n/* istanbul ignore next */\nconst METHOD_NAMES_ARE_QUOTED = {\n    \" \"() {\n        /* Empty. */\n    }\n}[\" \"]\n    .toString()\n    .charAt(0) === '\"';\nconst FUNCTION_PREFIXES = {\n    Function: \"function \",\n    GeneratorFunction: \"function* \",\n    AsyncFunction: \"async function \",\n    AsyncGeneratorFunction: \"async function* \"\n};\nconst METHOD_PREFIXES = {\n    Function: \"\",\n    GeneratorFunction: \"*\",\n    AsyncFunction: \"async \",\n    AsyncGeneratorFunction: \"async *\"\n};\nconst TOKENS_PRECEDING_REGEXPS = new Set((\"case delete else in instanceof new return throw typeof void \" +\n    \", ; : + - ! ~ & | ^ * / % < > ? =\").split(\" \"));\n/**\n * Track function parser usage.\n */\nexports.USED_METHOD_KEY = new WeakSet();\n/**\n * Stringify a function.\n */\nexports.functionToString = (fn, space, next, key) => {\n    const name = typeof key === \"string\" ? key : undefined;\n    // Track in function parser for object stringify to avoid duplicate output.\n    if (name !== undefined)\n        exports.USED_METHOD_KEY.add(fn);\n    return new FunctionParser(fn, space, next, name).stringify();\n};\n/**\n * Rewrite a stringified function to remove initial indentation.\n */\nfunction dedentFunction(fnString) {\n    let found;\n    for (const line of fnString.split(\"\\n\").slice(1)) {\n        const m = /^[\\s\\t]+/.exec(line);\n        if (!m)\n            return fnString; // Early exit without indent.\n        const [str] = m;\n        if (found === undefined)\n            found = str;\n        else if (str.length < found.length)\n            found = str;\n    }\n    return found ? fnString.split(`\\n${found}`).join(\"\\n\") : fnString;\n}\nexports.dedentFunction = dedentFunction;\n/**\n * Function parser and stringify.\n */\nclass FunctionParser {\n    constructor(fn, indent, next, key) {\n        this.fn = fn;\n        this.indent = indent;\n        this.next = next;\n        this.key = key;\n        this.pos = 0;\n        this.hadKeyword = false;\n        this.fnString = Function.prototype.toString.call(fn);\n        this.fnType = fn.constructor.name;\n        this.keyQuote = key === undefined ? \"\" : quote_1.quoteKey(key, next);\n        this.keyPrefix =\n            key === undefined ? \"\" : `${this.keyQuote}:${indent ? \" \" : \"\"}`;\n        this.isMethodCandidate =\n            key === undefined ? false : this.fn.name === \"\" || this.fn.name === key;\n    }\n    stringify() {\n        const value = this.tryParse();\n        // If we can't stringify this function, return a void expression; for\n        // bonus help with debugging, include the function as a string literal.\n        if (!value) {\n            return `${this.keyPrefix}void ${this.next(this.fnString)}`;\n        }\n        return dedentFunction(value);\n    }\n    getPrefix() {\n        if (this.isMethodCandidate && !this.hadKeyword) {\n            return METHOD_PREFIXES[this.fnType] + this.keyQuote;\n        }\n        return this.keyPrefix + FUNCTION_PREFIXES[this.fnType];\n    }\n    tryParse() {\n        if (this.fnString[this.fnString.length - 1] !== \"}\") {\n            // Must be an arrow function.\n            return this.keyPrefix + this.fnString;\n        }\n        // Attempt to remove function prefix.\n        if (this.fn.name) {\n            const result = this.tryStrippingName();\n            if (result)\n                return result;\n        }\n        // Support class expressions.\n        const prevPos = this.pos;\n        if (this.consumeSyntax() === \"class\")\n            return this.fnString;\n        this.pos = prevPos;\n        if (this.tryParsePrefixTokens()) {\n            const result = this.tryStrippingName();\n            if (result)\n                return result;\n            let offset = this.pos;\n            switch (this.consumeSyntax(\"WORD_LIKE\")) {\n                case \"WORD_LIKE\":\n                    if (this.isMethodCandidate && !this.hadKeyword) {\n                        offset = this.pos;\n                    }\n                // tslint:disable-next-line no-switch-case-fall-through\n                case \"()\":\n                    if (this.fnString.substr(this.pos, 2) === \"=>\") {\n                        return this.keyPrefix + this.fnString;\n                    }\n                    this.pos = offset;\n                // tslint:disable-next-line no-switch-case-fall-through\n                case '\"':\n                case \"'\":\n                case \"[]\":\n                    return this.getPrefix() + this.fnString.substr(this.pos);\n            }\n        }\n    }\n    /**\n     * Attempt to parse the function from the current position by first stripping\n     * the function's name from the front. This is not a fool-proof method on all\n     * JavaScript engines, but yields good results on Node.js 4 (and slightly\n     * less good results on Node.js 6 and 8).\n     */\n    tryStrippingName() {\n        if (METHOD_NAMES_ARE_QUOTED) {\n            // ... then this approach is unnecessary and yields false positives.\n            return;\n        }\n        let start = this.pos;\n        const prefix = this.fnString.substr(this.pos, this.fn.name.length);\n        if (prefix === this.fn.name) {\n            this.pos += prefix.length;\n            if (this.consumeSyntax() === \"()\" &&\n                this.consumeSyntax() === \"{}\" &&\n                this.pos === this.fnString.length) {\n                // Don't include the function's name if it will be included in the\n                // prefix, or if it's invalid as a name in a function expression.\n                if (this.isMethodCandidate || !quote_1.isValidVariableName(prefix)) {\n                    start += prefix.length;\n                }\n                return this.getPrefix() + this.fnString.substr(start);\n            }\n        }\n        this.pos = start;\n    }\n    /**\n     * Attempt to advance the parser past the keywords expected to be at the\n     * start of this function's definition. This method sets `this.hadKeyword`\n     * based on whether or not a `function` keyword is consumed.\n     *\n     * @return {boolean}\n     */\n    tryParsePrefixTokens() {\n        let posPrev = this.pos;\n        this.hadKeyword = false;\n        switch (this.fnType) {\n            case \"AsyncFunction\":\n                if (this.consumeSyntax() !== \"async\")\n                    return false;\n                posPrev = this.pos;\n            // tslint:disable-next-line no-switch-case-fall-through\n            case \"Function\":\n                if (this.consumeSyntax() === \"function\") {\n                    this.hadKeyword = true;\n                }\n                else {\n                    this.pos = posPrev;\n                }\n                return true;\n            case \"AsyncGeneratorFunction\":\n                if (this.consumeSyntax() !== \"async\")\n                    return false;\n            // tslint:disable-next-line no-switch-case-fall-through\n            case \"GeneratorFunction\":\n                let token = this.consumeSyntax();\n                if (token === \"function\") {\n                    token = this.consumeSyntax();\n                    this.hadKeyword = true;\n                }\n                return token === \"*\";\n        }\n    }\n    /**\n     * Advance the parser past one element of JavaScript syntax. This could be a\n     * matched pair of delimiters, like braces or parentheses, or an atomic unit\n     * like a keyword, variable, or operator. Return a normalized string\n     * representation of the element parsed--for example, returns '{}' for a\n     * matched pair of braces. Comments and whitespace are skipped.\n     *\n     * (This isn't a full parser, so the token scanning logic used here is as\n     * simple as it can be. As a consequence, some things that are one token in\n     * JavaScript, like decimal number literals or most multicharacter operators\n     * like '&&', are split into more than one token here. However, awareness of\n     * some multicharacter sequences like '=>' is necessary, so we match the few\n     * of them that we care about.)\n     */\n    consumeSyntax(wordLikeToken) {\n        const m = this.consumeMatch(/^(?:([A-Za-z_0-9$\\xA0-\\uFFFF]+)|=>|\\+\\+|\\-\\-|.)/);\n        if (!m)\n            return;\n        const [token, match] = m;\n        this.consumeWhitespace();\n        if (match)\n            return wordLikeToken || match;\n        switch (token) {\n            case \"(\":\n                return this.consumeSyntaxUntil(\"(\", \")\");\n            case \"[\":\n                return this.consumeSyntaxUntil(\"[\", \"]\");\n            case \"{\":\n                return this.consumeSyntaxUntil(\"{\", \"}\");\n            case \"`\":\n                return this.consumeTemplate();\n            case '\"':\n                return this.consumeRegExp(/^(?:[^\\\\\"]|\\\\.)*\"/, '\"');\n            case \"'\":\n                return this.consumeRegExp(/^(?:[^\\\\']|\\\\.)*'/, \"'\");\n        }\n        return token;\n    }\n    consumeSyntaxUntil(startToken, endToken) {\n        let isRegExpAllowed = true;\n        for (;;) {\n            const token = this.consumeSyntax();\n            if (token === endToken)\n                return startToken + endToken;\n            if (!token || token === \")\" || token === \"]\" || token === \"}\")\n                return;\n            if (token === \"/\" &&\n                isRegExpAllowed &&\n                this.consumeMatch(/^(?:\\\\.|[^\\\\\\/\\n[]|\\[(?:\\\\.|[^\\]])*\\])+\\/[a-z]*/)) {\n                isRegExpAllowed = false;\n                this.consumeWhitespace();\n            }\n            else {\n                isRegExpAllowed = TOKENS_PRECEDING_REGEXPS.has(token);\n            }\n        }\n    }\n    consumeMatch(re) {\n        const m = re.exec(this.fnString.substr(this.pos));\n        if (m)\n            this.pos += m[0].length;\n        return m;\n    }\n    /**\n     * Advance the parser past an arbitrary regular expression. Return `token`,\n     * or the match object of the regexp.\n     */\n    consumeRegExp(re, token) {\n        const m = re.exec(this.fnString.substr(this.pos));\n        if (!m)\n            return;\n        this.pos += m[0].length;\n        this.consumeWhitespace();\n        return token;\n    }\n    /**\n     * Advance the parser past a template string.\n     */\n    consumeTemplate() {\n        for (;;) {\n            this.consumeMatch(/^(?:[^`$\\\\]|\\\\.|\\$(?!{))*/);\n            if (this.fnString[this.pos] === \"`\") {\n                this.pos++;\n                this.consumeWhitespace();\n                return \"`\";\n            }\n            if (this.fnString.substr(this.pos, 2) === \"${\") {\n                this.pos += 2;\n                this.consumeWhitespace();\n                if (this.consumeSyntaxUntil(\"{\", \"}\"))\n                    continue;\n            }\n            return;\n        }\n    }\n    /**\n     * Advance the parser past any whitespace or comments.\n     */\n    consumeWhitespace() {\n        this.consumeMatch(/^(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/);\n    }\n}\nexports.FunctionParser = FunctionParser;\n//# sourceMappingURL=function.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst quote_1 = require(\"./quote\");\nconst function_1 = require(\"./function\");\nconst array_1 = require(\"./array\");\n/**\n * Transform an object into a string.\n */\nexports.objectToString = (value, space, next, key) => {\n    if (typeof Buffer === \"function\" && Buffer.isBuffer(value)) {\n        return `new Buffer(${next(value.toString())})`;\n    }\n    // Use the internal object string to select stringify method.\n    const toString = OBJECT_TYPES[Object.prototype.toString.call(value)];\n    return toString ? toString(value, space, next, key) : undefined;\n};\n/**\n * Stringify an object of keys and values.\n */\nconst rawObjectToString = (obj, indent, next) => {\n    const eol = indent ? \"\\n\" : \"\";\n    const space = indent ? \" \" : \"\";\n    // Iterate over object keys and concat string together.\n    const values = Object.keys(obj)\n        .reduce(function (values, key) {\n        const fn = obj[key];\n        const result = next(fn, key);\n        // Omit `undefined` object entries.\n        if (result === undefined)\n            return values;\n        // String format the value data.\n        const value = result.split(\"\\n\").join(`\\n${indent}`);\n        // Skip `key` prefix for function parser.\n        if (function_1.USED_METHOD_KEY.has(fn)) {\n            values.push(`${indent}${value}`);\n            return values;\n        }\n        values.push(`${indent}${quote_1.quoteKey(key, next)}:${space}${value}`);\n        return values;\n    }, [])\n        .join(`,${eol}`);\n    // Avoid new lines in an empty object.\n    if (values === \"\")\n        return \"{}\";\n    return `{${eol}${values}${eol}}`;\n};\n/**\n * Stringify global variable access.\n */\nconst globalToString = (value, space, next) => {\n    return `Function(${next(\"return this\")})()`;\n};\n/**\n * Convert JavaScript objects into strings.\n */\nconst OBJECT_TYPES = {\n    \"[object Array]\": array_1.arrayToString,\n    \"[object Object]\": rawObjectToString,\n    \"[object Error]\": (error, space, next) => {\n        return `new Error(${next(error.message)})`;\n    },\n    \"[object Date]\": (date) => {\n        return `new Date(${date.getTime()})`;\n    },\n    \"[object String]\": (str, space, next) => {\n        return `new String(${next(str.toString())})`;\n    },\n    \"[object Number]\": (num) => {\n        return `new Number(${num})`;\n    },\n    \"[object Boolean]\": (bool) => {\n        return `new Boolean(${bool})`;\n    },\n    \"[object Set]\": (set, space, next) => {\n        return `new Set(${next(Array.from(set))})`;\n    },\n    \"[object Map]\": (map, space, next) => {\n        return `new Map(${next(Array.from(map))})`;\n    },\n    \"[object RegExp]\": String,\n    \"[object global]\": globalToString,\n    \"[object Window]\": globalToString\n};\n//# sourceMappingURL=object.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Stringify an array of values.\n */\nexports.arrayToString = (array, space, next) => {\n    // Map array values to their stringified values with correct indentation.\n    const values = array\n        .map(function (value, index) {\n        const result = next(value, index);\n        if (result === undefined)\n            return String(result);\n        return space + result.split(\"\\n\").join(`\\n${space}`);\n    })\n        .join(space ? \",\\n\" : \",\");\n    const eol = space && values ? \"\\n\" : \"\";\n    return `[${eol}${values}${eol}]`;\n};\n//# sourceMappingURL=array.js.map","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst quote_1 = require(\"./quote\");\nconst object_1 = require(\"./object\");\nconst function_1 = require(\"./function\");\n/**\n * Stringify primitive values.\n */\nconst PRIMITIVE_TYPES = {\n    string: quote_1.quoteString,\n    number: (value) => (Object.is(value, -0) ? \"-0\" : String(value)),\n    boolean: String,\n    symbol: (value, space, next) => {\n        const key = Symbol.keyFor(value);\n        if (key !== undefined)\n            return `Symbol.for(${next(key)})`;\n        // ES2018 `Symbol.description`.\n        return `Symbol(${next(value.description)})`;\n    },\n    bigint: (value, space, next) => {\n        return `BigInt(${next(String(value))})`;\n    },\n    undefined: String,\n    object: object_1.objectToString,\n    function: function_1.functionToString\n};\n/**\n * Stringify a value recursively.\n */\nexports.toString = (value, space, next, key) => {\n    if (value === null)\n        return \"null\";\n    return PRIMITIVE_TYPES[typeof value](value, space, next, key);\n};\n//# sourceMappingURL=stringify.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Match all characters that need to be escaped in a string. Modified from\n * source to match single quotes instead of double.\n *\n * Source: https://github.com/douglascrockford/JSON-js/blob/master/json2.js\n */\nconst ESCAPABLE = /[\\\\\\'\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n/**\n * Map of characters to escape characters.\n */\nconst META_CHARS = new Map([\n    [\"\\b\", \"\\\\b\"],\n    [\"\\t\", \"\\\\t\"],\n    [\"\\n\", \"\\\\n\"],\n    [\"\\f\", \"\\\\f\"],\n    [\"\\r\", \"\\\\r\"],\n    [\"'\", \"\\\\'\"],\n    ['\"', '\\\\\"'],\n    [\"\\\\\", \"\\\\\\\\\"]\n]);\n/**\n * Escape any character into its literal JavaScript string.\n *\n * @param  {string} char\n * @return {string}\n */\nfunction escapeChar(char) {\n    return (META_CHARS.get(char) ||\n        `\\\\u${`0000${char.charCodeAt(0).toString(16)}`.slice(-4)}`);\n}\n/**\n * Quote a string.\n */\nfunction quoteString(str) {\n    return `'${str.replace(ESCAPABLE, escapeChar)}'`;\n}\nexports.quoteString = quoteString;\n/**\n * JavaScript reserved keywords.\n */\nconst RESERVED_WORDS = new Set((\"break else new var case finally return void catch for switch while \" +\n    \"continue function this with default if throw delete in try \" +\n    \"do instanceof typeof abstract enum int short boolean export \" +\n    \"interface static byte extends long super char final native synchronized \" +\n    \"class float package throws const goto private transient debugger \" +\n    \"implements protected volatile double import public let yield\").split(\" \"));\n/**\n * Test for valid JavaScript identifier.\n */\nexports.IS_VALID_IDENTIFIER = /^[A-Za-z_$][A-Za-z0-9_$]*$/;\n/**\n * Check if a variable name is valid.\n */\nfunction isValidVariableName(name) {\n    return (typeof name === \"string\" &&\n        !RESERVED_WORDS.has(name) &&\n        exports.IS_VALID_IDENTIFIER.test(name));\n}\nexports.isValidVariableName = isValidVariableName;\n/**\n * Quote JavaScript key access.\n */\nfunction quoteKey(key, next) {\n    return isValidVariableName(key) ? key : next(key);\n}\nexports.quoteKey = quoteKey;\n/**\n * Serialize the path to a string.\n */\nfunction stringifyPath(path, next) {\n    let result = \"\";\n    for (const key of path) {\n        if (isValidVariableName(key)) {\n            result += `.${key}`;\n        }\n        else {\n            result += `[${next(key)}]`;\n        }\n    }\n    return result;\n}\nexports.stringifyPath = stringifyPath;\n//# sourceMappingURL=quote.js.map"],"sourceRoot":""}